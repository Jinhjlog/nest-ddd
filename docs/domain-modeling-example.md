# 전자상거래 도메인 예시를 통한 DDD 구현

## 프로젝트 구조

```text
📦src
 ┣ 📂lib    # 공통 도메인 기반 클래스 및 유틸리티
 ┃ ┗ 📂domain # 도메인 기본 클래스 (Entity, ValueObject 등)
 ┃ ┃ ┣ 📂...
 ┣ 📂module    # 모듈별 구현
 ┃ ┣ 📂core    # 핵심 인프라 모듈 (데이터베이스 등)
 ┃ ┃ ┗ 📂...
 ┃ ┣ 📂 {domain-name}    # 각 도메인별 모듈
 ┃ ┃ ┣ 📂application    # 애플리케이션 계층
 ┃ ┃ ┃ ┣ 📂dtos    # 애플리케이션 계층 DTO
 ┃ ┃ ┃ ┗ 📂usecases    # 유즈케이스 구현
 ┃ ┃ ┣ 📂domain    # 도메인 모델
 ┃ ┃ ┃ ┣ 📂models    # 엔티티, 값 객체 등 도메인 모델
 ┃ ┃ ┃ ┣ 📂repositories    # 리포지토리 인터페이스
 ┃ ┃ ┃ ┗ 📂services    # 도메인 서비스
 ┃ ┃ ┣ 📂infra    # 인프라스트럭처 계층
 ┃ ┃ ┃ ┣ 📂services    # 서비스 구현체
 ┃ ┃ ┃ ┣ 📂mappers    # ORM 매핑 클래스
 ┃ ┃ ┃ ┗ 📂repositories    # 레포지토리 구현체
 ┃ ┃ ┗ 📂presentation    # 프레젠테이션 계층
 ┃ ┃ ┃ ┣ 📂controllers    # API 컨트롤러
 ┃ ┃ ┃ ┗ 📂dtos    # 요청/응답 DTO
 ┃ ┃ ┃ ┃ ┣ 📂request
 ┃ ┃ ┃ ┃ ┗ 📂response
```

# 도메인 모델링 과정: 전자상거래 예시

## 도메인 전문가와의 대화 (유비쿼터스 언어 발견)

### 전자상거래 도메인 전문가와의 대화 예시:

> "고객은 여러 상품을 장바구니에 담고 주문을 생성할 수 있습니다. 주문은 여러 주문 항목으로 구성되며, 각 항목은 상품과 수량을 가집니다. 주문이 생성되면 결제 과정을 거쳐 배송이 시작됩니다. 배송은 여러 배송 상태(준비중, 배송중, 배송완료)를 거치게 됩니다."

이 대화에서 발견된 핵심 개념들:

- 고객(Customer)
- 상품(Product)
- 장바구니(Cart)
- 주문(Order)
- 주문 항목(OrderItem)
- 결제(Payment)
- 배송(Shipment)

## 애그리게잇, 엔티티, 값 객체 구분 기준

### 엔티티로 모델링하는 경우

- **식별자로 구분되는 객체**: 객체가 시간에 따라 변경되어도 동일한 객체로 인식되어야 할 때
- **생명주기가 있는 객체**: 생성, 수정, 삭제 등의 생명주기를 가지는 객체
- **다른 객체와의 관계를 가지는 객체**: 다른 객체와의 관계를 통해 비즈니스 규칙을 표현해야 할 때

### 값 객체로 모델링하는 경우

- **속성의 묶음으로 표현되는 개념**: 여러 속성이 하나의 개념을 표현할 때 (예: 주소, 금액)
- **불변성이 중요한 개념**: 생성 후 변경되지 않아야 하는 개념
- **동등성으로 비교되는 개념**: 내부 값이 같으면 같은 객체로 취급되어야 할 때
- **측정, 수량, 설명 등을 표현하는 개념**: 비즈니스 규칙이 포함된 값 (예: 이메일, 전화번호)

### 애그리게잇으로 모델링하는 경우

- **트랜잭션 일관성 경계**: 함께 변경되어야 하는 객체들의 집합
- **비즈니스 규칙의 집합**: 관련된 비즈니스 규칙을 함께 적용해야 하는 객체들
- **접근 제어 단위**: 외부에서 직접 접근해서는 안 되는 객체들을 보호해야 할 때

## 전자상거래 도메인 구현 예시

### 애그리게잇 식별 및 경계 설정

전자상거래 도메인에서 식별된 애그리게잇

- **주문 애그리게잇**: 주문, 주문 항목
- **상품 애그리게잇**: 상품, 상품 카테고리
- **고객 애그리게잇**: 고객, 주소
- **배송 애그리게잇**: 배송, 배송 항목

### 경계 설정 근거

전자상거래 도메인에서 애그리게잇을 식별하고 경계를 설정할 떄는 다음과 같은 원칙을 고려했습니다.

1. **트랜잭션 일관성**: 함께 변경되어야 하는 객체들을 하나의 애그리게잇으로 그룹화
2. **비즈니스 규칙**: 동일한 비즈니스 규칙이 적용되는 객체들을 함께 관리
3. **성능과 확장성**: 애그리게잇 크기를 관리 가능한 수준으로 유지
4. **도메인 전문가의 관점**: 도메인 전문가가 인식하는 개념적 경계 반영

### 주문 애그리게잇 (Order Aggregate)

**포함 엔티티/값 객체**: 주문(Order), 주문 항목(OrderItem)

**경계 설정 근거**:

- **트랜잭션 일관성**: 주문과 주문 항목은 함께 생성되고 수정되어야 합니다. 주문 항목이 변경되면 주문의 총액도 함께 업데이트되어야 합니다.
- **비즈니스 규칙**: 주문은 최소 하나 이상의 주문 항목을 포함해야 하며, 주문 상태 변경 시 모든 항목에 대한 유효성 검증이 필요합니다.
- **접근 제어**: 주문 항목은 주문을 통해서만 접근되어야 하며, 외부에서 직접 주문 항목을 수정할 수 없습니다.
- **생명주기 관리**: 주문 항목은 주문에 종속적이며, 주문이 삭제되면 관련 주문 항목도 함께 삭제되어야 합니다.

**다른 애그리게잇과의 관계**:

- 상품 애그리게잇은 ID로만 참조합니다(주문 항목의 productId).
- 고객 애그리게잇은 ID로만 참조합니다(주문의 customerId).

### 상품 애그리게잇 (Product Aggregate)

**포함 엔티티/값 객체**: 상품(Product), 상품 카테고리(ProductCategory)

**경계 설정 근거**:

- **비즈니스 개념적 완전성**: 상품과 그 카테고리는 함께 상품의 완전한 정보를 구성합니다.
- **재고 관리**: 상품의 재고 변경은 원자적으로 이루어져야 하며, 이는 상품 애그리게잇 내에서 관리됩니다.
- **카테고리 변경**: 상품의 카테고리 변경은 상품 정보의 일부로 간주되며, 함께 관리되어야 합니다.
- **검색 및 필터링**: 상품과 카테고리는 함께 검색 및 필터링 작업에 사용됩니다.

**다른 애그리게잇과의 관계**:

- 주문 애그리게잇에서 ID로 참조됩니다.
- 카테고리가 많고 복잡한 경우, 카테고리를 별도 애그리게잇으로 분리할 수도 있지만, 이 예시에서는 단순화를 위해 함께 관리합니다.

### 고객 애그리게잇 (Customer Aggregate)

전자거래 시스템에서는 일반적으로 고객이 여러 배송지 주소를 관리합니다.  
이 경우 고객 애그리게잇은 다음과 같이 구성됩니다.

- **고객(Customer)**: 애그리게잇 루트
- **주소(Address)**: 엔티티 (여러 개 존재 가능)

**경계 설정 근거**:

- **인증 및 권한**: 고객 인증 및 권한 관리는 고객 애그리게잇 내에서 처리됩니다.
- **개인 정보 관리**: 고객 정보와 주소는 개인 정보로서 함께 관리되어야 합니다.
- **참조 필요성**: 주문 생성 시 고객의 특정 주소를 참조해야 합니다.
- **독립적인 생명주기**: 각 주소는 고객과 독립적으로 추가, 수정, 삭제될 수 있습니다.
- **식별 필요성**: 여러 주소 중 특정 주소를 식별하기 위해 고유 ID가 필요합니다.
- **비즈니스 규칙**: 기본 배송지 설정, 주소 유형 관리 등의 규칙이 적용됩니다.

**다른 애그리게잇과의 관계**:

- 주문 애그리게잇에서는 고객 ID와 함께 사용할 주소 ID를 참조할 수 있습니다.
- 주문 생성 시 주소 정보를 값 객체로 복사하여 포함시킬 수 있습니다(주소 변경이 기존 주문에 영향을 미치지 않도록).

### 장바구니 애그리게잇 (Cart Aggregate)

**포함 엔티티/값 객체**: 장바구니(Cart), 장바구니 항목(CartItem)

**경계 설정 근거**:

- **독립적인 생명주기**: 장바구니는 고객과 별개로 생성, 수정, 삭제될 수 있으며, 비로그인 상태에서도 존재할 수 있습니다.
- **트랜잭션 일관성**: 장바구니와 장바구니 항목은 함께 변경되어야 합니다. 항목 추가/제거/수량 변경 시 장바구니 총액도 함께 업데이트되어야 합니다.
- **성능 최적화**: 장바구니 조작이 빈번하므로, 고객 데이터와 분리하여 효율적인 로드/저장이 가능합니다.
- **비즈니스 규칙**: 재고 확인, 수량 제한, 할인 적용 등의 규칙이 장바구니 수준에서 적용됩니다.

**다른 애그리게잇과의 관계**:

- 상품 애그리게잇은 ID로만 참조합니다(장바구니 항목의 productId).
- 고객 애그리게잇은 ID로만 참조합니다(장바구니의 customerId). 비로그인 상태에서는 null이 될 수 있습니다.
- 장바구니가 주문으로 전환될 때, 장바구니 정보를 기반으로 새로운 주문 애그리게잇이 생성됩니다.

### 배송 애그리게잇 (Shipment Aggregate)

**포함 엔티티/값 객체**: 배송(Shipment), 배송 항목(ShipmentItem)

**경계 설정 근거**:

- **독립적인 생명주기**: 배송은 주문 이후 독립적인 생명주기를 가집니다. 주문이 확정된 후에도 배송 상태는 계속 변경될 수 있습니다.
- **배송 프로세스 관리**: 배송 준비, 발송, 배달 등의 프로세스는 주문과 별개로 관리되어야 합니다.
- **배송 항목 추적**: 각 배송 항목의 상태를 개별적으로 추적해야 할 필요가 있습니다.
- **물류 시스템 통합**: 배송은 외부 물류 시스템과 통합되는 경우가 많아 독립적인 관리가 필요합니다.

**다른 애그리게잇과의 관계**:

- 주문 애그리게잇은 ID로 참조합니다(배송의 orderId).
- 배송 항목은 주문 항목을 ID로 참조할 수 있습니다.

## 애그리게잇 경계 설정의 트레이드오프

이러한 애그리게잇 경계 설정에는 다음과 같은 트레이드오프가 고려되었습니다.

1. **일관성 vs 성능**:

   - 더 큰 애그리게잇은 강한 일관성을 제공하지만 성능과 확장성에 영향을 줄 수 있습니다.
   - 예: 주문과 배송을 하나의 애그리게잇으로 합칠 수도 있지만, 이는 배송 상태 변경 시마다 전체 주문 데이터를 로드해야 하는 성능 문제를 야기할 수 있습니다.

2. **단순성 vs 정확성**:

   - 더 세분화된 애그리게잇은 도메인을 더 정확하게 모델링할 수 있지만 복잡성이 증가합니다.
   - 예: 상품과 카테고리를 별도 애그리게잇으로 분리하면 더 정확할 수 있지만, 관리가 복잡해집니다.

3. **즉시 일관성 vs 최종 일관성**:
   - 애그리게잇 간 참조는 ID만 사용하므로, 애그리게잇 간 변경은 최종 일관성(eventual consistency)으로 처리됩니다.
   - 예: 상품 가격 변경이 기존 장바구니에 즉시 반영되지 않을 수 있습니다.

이러한 트레이드오프를 고려하여 비즈니스 요구사항에 가장 적합한 애그리게잇 경계를 설정하는 것이 중요합니다.
