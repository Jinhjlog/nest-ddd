# Nest-ddd

# Architecture

### 프레젠테이션 계층 (Presentation Layer)

프레젠테이션 계층을 사용자 또는 외부 시스템과의 상호작용을 담당합니다.

- 컨트롤러: HTTP 요청을 처리하고 응답을 반환합니다.
- 요청/응답 DTO: API 요청과 응답의 데이터 구조를 정의합니다.
- 인증/인가 처리: API 엔드포인트에 대한 접근 제어를 관리합니다.

### 애플리케이션 계층 (Application Layer)

애플리케이션 계층은 유스케이스를 조정하고 도메인 객체와 서비스의 상호작용을 관리합니다.

- 유스케이스 (UseCase):비즈니스 시나리오를 구현합니다.
- 응용 DTO: 애플리케이션 계층 내부 데이터 전송 객체를 정의합니다.

### 도메인 계층 (Domain Layer)

도메인 계층은 비즈니스 규칙과 도메인 개념을 캡슐화하는 핵심 계층입니다.
도메인 모델
도메인 서비스
서비스 인터페이스
레포지토리 인터페이스

### 인프라스트럭쳐 계층 (Infrastructure Layer)

인프라스트럭쳐 계층은 기술적 관심사와 외부 시스템 통합을 담당합니다.
레포지토리 구현체: 영속성 처리를 구현합니다.
외부 서비스 통합: 외부 API와의 통신을 처리합니다.
ORM 매핑: 데이터베이스 엔티티와 도메인 객체 간 변환을 관리합니다.

### 아키텍처 원칙

1. 의존성 규칙: 모든 의존성은 내부 계층을 향합니다. 내부 계층은 외부 계층에 의존하지 않습니다.
2. 관심사 분리: 각 계층은 명확한 책임을 가지며, 그 책임에만 집중합니다.
3. 도메인 중심: 도메인 계층이 핵심이며, 비즈니스 규칙이 가장 중요합니다.
4. 인프라스트럭쳐 독립성: 도메인과 애플리케이션 계층은 인프라스트럭처 세부사항에 의존하지 않습니다.

### 아키텍처 다이어그램

![아키텍처 다이어그램 이미지](/architecture-diagram.png)

# DDD

## DDD의 목표

도메인 주도 설계(DDD)의 목표
DDD는 비즈니스 도메인을 코드로 효과적으로 표현하는 것을 목표로 합니다:

- 도메인 전문가와의 지속적인 소통을 통해 도메인 모델을 발견합니다
- 비즈니스 규칙을 반영하는 풍부한 도메인 모델을 구축합니다
- 기술적 복잡성으로부터 도메인 모델을 보호합니다
- 유비쿼터스 언어(공통 언어)를 통해 개발자와 도메인 전문가 간 소통을 강화합니다

## 유비쿼터스 언어란?

유비쿼터스 언어는 도메인 모델의 개념을 표현하는 공통 언어입니다:

- 도메인 전문가와 개발자 간 사용하는 통일된 용어입니다
- 코드, 문서, 대화에서 일관되게 사용됩니다
- 도메인 모델의 구성 요소 명명에 직접 반영됩니다

### 서브 도메인(Sub Domain)

각각의 다른 문제 주제를 갖고 있는 영역들은 DDD에서 서브도메인이라고 합니다.

![서브 도메인 이미지](/sub-domain.png)

해결해야하는 문제를 각각 쪼개서 나누는 이유는 다음과 같습니다  
- 단일 책임 원칙 (소프트웨어 설계에서도 해당 원칙을 적용합니다)
- 프로그래머나 비프로그래머들이 사업의 내용을 모두 알 수 없습니다 (중간에 개발자가 투입되는 경우 하나로 얽혀있다면 주문, 회원, 상품에 대한 내용을 모두 파악해야 합니다)
- 서버가 도메인별로 존재하는 경우에 효율적입니다  

### 바운디드 컨텍스트(Bounded Context)

바운디드 컨텍스트는 특정 도메인 모델이 적용되는 명확한 경계를 의미합니다:

- 각 컨텍스트 내에서는 특정 용어가 일관된 의미를 가집니다
- 서로 다른 바운디드 컨텍스트 간에는 같은 용어가 다른 의미를 가질 수 있습니다
- 컨텍스트 맵(Context Map)을 통해 바운디드 컨텍스트 간의 관계를 명확히 합니다
- 각 바운디드 컨텍스트는 독립적으로 개발 및 배포될 수 있습니다

## 도메인 모델 설계

도메인 모델은 요구사항을 추상화한 것입니다

### DDD의 핵심 엔티티 (Entity)

소프트웨어 세상에서는 실제 세상에 있는 사물을 코드로 추상화하는데, 엔티티가 실제 사물을 추상화한 하나의 산물입니다.

**엔티티의 특징은 무엇인가요?**
엔티티는 이름(식별 아이디)을 통해 사물이 구분됩니다.
-> 내부의 값이 다르더라도 이름(id)값이 동일하면 서로 같은 사물로 판단합니다

**엔티티 구현 시 고려사항:**

- 고유 식별자(ID)를 통해 구별됩니다
- 생명주기를 가지고 있습니다
- 불변식(invariant)을 통해 일관성을 유지해야 합니다
- 비즈니스 규칙을 캡슐화해야 합니다
- TypeScript에서는 클래스로 구현하는 것이 일반적입니다

### 값 객체 (Value Object)

DDD의 레고 플러그인 중 하나입니다.
Value Object는 사물의 특성을 추상화합니다.
현실 세계에서 어떤 사물의 특성을 표현하는데 사용합니다.

**값 객체의 특징:**

- 식별자가 없습니다
- 불변(immutable)으로 설계됩니다
- 동등성은 모든 속성 값의 동등성으로 판단합니다
- 개념적 완전함을 가져야 합니다

예시) 이메일은 서비스 내에서 무언가 행동을 하는 주체가 아니라 어떤 주체의 특성을 나타내는 값이기 때문에 동등 비교는 value object가 가진 value로 비교를 합니다.

### 애그리게잇과 애그리게잇 루트 (Aggregate & Aggregate Root)

애그리게잇은 연관된 엔티티들의 집합으로, 하나의 단위로 취급됩니다. 애그리게잇 루트는 이 집합의 진입점 역할을 하는 대표 엔티티입니다.

**애그리게잇 루트 엔티티의 주요 책임:**

1. 애그리게잇 내부의 모든 객체들을 관리하고 제어합니다.
2. 애그리게잇 루트 엔티티의 불변성을 보장합니다.
3. 애그리게잇 루트 엔티티와 다른 객체 간의 관계를 관리합니다.
4. 애그리게잇 루트 엔티티를 통해 애그리거트 전체를 제어합니다.

**애그리게잇 루트 규칙:**

- 애그리게잇 1개당 하나의 레포지토리 클래스를 가질 수 있습니다.
- 애그리게잇이라는 영역 내에 연관되어 있는 도메인이 존재하며 대표 애그리게잇, 즉 애그리게잇 루트 엔티티를 통해 연관되어 있는 엔티티를 관리합니다.
  - 애그리게잇 루트를 통해 조회 및 생성, 수정, 관리를 수행합니다.
- 다른 애그리게잇의 객체를 직접 참조하지 않고 ID로 참조합니다.
- 트랜잭션 일관성은 단일 애그리게잇 내에서만 유지합니다.

### 도메인 서비스 (Domain Service)

엔티티나 값 객체에 자연스럽게 속하지 않는 도메인 로직은 도메인 서비스에 배치합니다:

- 여러 엔티티에 걸친 연산을 수행합니다
- 비즈니스 규칙이 특정 엔티티에 속하지 않을 때 사용합니다
- 상태를 가지지 않습니다 (무상태)

### 레포지토리 (Repository)

애그리게잇의 영속성을 담당하는 인터페이스입니다:

- 애그리게잇 루트 당 하나의 레포지토리를 가집니다
- 도메인 모델에 영속성 메커니즘을 숨깁니다
- 컬렉션과 유사한 인터페이스를 제공합니다
- 인프라스트럭처 계층에서 구현합니다

// 도메인 계층의 리포지토리 인터페이스
export interface OrderRepository {
findById(id: OrderId): Promise<Order | null>;
save(order: Order): Promise<void>;
remove(order: Order): Promise<void>;
findByCustomerId(customerId: CustomerId): Promise<Order[]>;
}

### 도메인 이벤트 (Domain Events)

도메인 내에서 발생한 중요한 사건을 표현합니다:

- 도메인 내 변경 사항을 다른 부분에 알립니다
- 애그리게잇 간의 결합도를 낮춥니다
- 이벤트 소싱(Event Sourcing) 패턴에 기반이 됩니다

# 에러 핸들링 전략

neverthrow 라이브러리 주요 개념
neverthrow는 다음 두 가지 주요 타입을 제공합니다:

Ok<T>: 성공적인 결과를 담는 컨테이너
Err<E>: 오류 정보를 담는 컨테이너
이 두 타입은 Result<T, E> 타입의 변형으로, 함수는 항상 Result<T, E> 타입을 반환합니다.

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
